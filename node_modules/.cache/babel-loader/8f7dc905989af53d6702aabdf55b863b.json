{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) : typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) : (global = global || self, factory(global.troika_three_utils = {}, global.THREE));\n})(this, function (exports, three) {\n  'use strict';\n\n  /**\n   * Regular expression for matching the `void main() {` opener line in GLSL.\n   * @type {RegExp}\n   */\n  var voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n  /**\n   * Recursively expands all `#include <xyz>` statements within string of shader code.\n   * Copied from three's WebGLProgram#parseIncludes for external use.\n   *\n   * @param {string} source - The GLSL source code to evaluate\n   * @return {string} The GLSL code with all includes expanded\n   */\n  function expandShaderIncludes(source) {\n    var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n      var chunk = three.ShaderChunk[include];\n      return chunk ? expandShaderIncludes(chunk) : match;\n    }\n    return source.replace(pattern, replace);\n  }\n\n  // Local assign polyfill to avoid importing troika-core\n  var assign = Object.assign || function /*target, ...sources*/\n  () {\n    var arguments$1 = arguments;\n    var target = arguments[0];\n    for (var i = 1, len = arguments.length; i < len; i++) {\n      var source = arguments$1[i];\n      if (source) {\n        for (var prop in source) {\n          if (source.hasOwnProperty(prop)) {\n            target[prop] = source[prop];\n          }\n        }\n      }\n    }\n    return target;\n  };\n  var idCtr = 0;\n  var epoch = Date.now();\n  var CACHE = new WeakMap(); //threejs requires WeakMap internally so should be safe to assume support\n\n  /**\n   * A utility for creating a custom shader material derived from another material's\n   * shaders. This allows you to inject custom shader logic and transforms into the\n   * builtin ThreeJS materials without having to recreate them from scratch.\n   *\n   * @param {THREE.Material} baseMaterial - the original material to derive from\n   *\n   * @param {Object} options - How the base material should be modified.\n   * @param {Object} options.defines - Custom `defines` for the material\n   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n   *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n   *        both shaders, and it will automatically be updated on each render frame with a number of\n   *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n   *        true calendar time.\n   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n   *        those attributes exposed by their normal names as read/write values.\n   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n   *        shader's `void main` function.\n   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n   *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n   *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n   *        want those to apply to your changes use `fragmentColorTransform` instead.\n   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n   *        output value. Will be injected near the end of the `void main` function, but before any\n   *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n   *        `fragmentMainOutro`.\n   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n   *        for performing custom rewrites of the full shader code. Useful if you need to do something\n   *        special that's not covered by the other builtin options. This function will be executed before\n   *        any other transforms are applied.\n   *\n   * @return {THREE.Material}\n   *\n   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n   * which can be called to get a variant of the derived material for use in shadow casting. If the\n   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n   * scenarios, e.g. skipping antialiasing or expensive shader logic.\n   */\n  function createDerivedMaterial(baseMaterial, options) {\n    // First check the cache to see if we've already derived from this baseMaterial using\n    // this unique set of options, and if so just return a clone instead of a new subclass\n    // which is faster and allows their shader program to be shared when rendering.\n    var optionsHash = getOptionsHash(options);\n    var cached = CACHE.get(baseMaterial);\n    if (!cached) {\n      cached = Object.create(null);\n      CACHE.set(baseMaterial, cached);\n    }\n    if (cached[optionsHash]) {\n      return cached[optionsHash].clone();\n    }\n    var id = ++idCtr;\n    var privateDerivedShadersProp = \"_derivedShaders\" + id;\n    var privateBeforeCompileProp = \"_onBeforeCompile\" + id;\n    var distanceMaterialTpl, depthMaterialTpl;\n\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n    function onBeforeCompile(shaderInfo) {\n      baseMaterial.onBeforeCompile.call(this, shaderInfo);\n\n      // Upgrade the shaders, caching the result\n      var ref = this[privateDerivedShadersProp] || (this[privateDerivedShadersProp] = {\n        vertex: {},\n        fragment: {}\n      });\n      var vertex = ref.vertex;\n      var fragment = ref.fragment;\n      if (vertex.source !== shaderInfo.vertexShader || fragment.source !== shaderInfo.fragmentShader) {\n        var upgraded = upgradeShaders(shaderInfo, options, id);\n        vertex.source = shaderInfo.vertexShader;\n        vertex.result = upgraded.vertexShader;\n        fragment.source = shaderInfo.fragmentShader;\n        fragment.result = upgraded.fragmentShader;\n      }\n\n      // Inject upgraded shaders and uniforms into the program\n      shaderInfo.vertexShader = vertex.result;\n      shaderInfo.fragmentShader = fragment.result;\n      assign(shaderInfo.uniforms, this.uniforms);\n\n      // Inject auto-updating time uniform if requested\n      if (options.timeUniform) {\n        shaderInfo.uniforms[options.timeUniform] = {\n          get value() {\n            return Date.now() - epoch;\n          }\n        };\n      }\n\n      // Users can still add their own handlers on top of ours\n      if (this[privateBeforeCompileProp]) {\n        this[privateBeforeCompileProp](shaderInfo);\n      }\n    }\n    function DerivedMaterial() {\n      baseMaterial.constructor.apply(this, arguments);\n      this._listeners = undefined; //don't inherit EventDispatcher listeners\n    }\n\n    DerivedMaterial.prototype = Object.create(baseMaterial, {\n      constructor: {\n        value: DerivedMaterial\n      },\n      isDerivedMaterial: {\n        value: true\n      },\n      baseMaterial: {\n        value: baseMaterial\n      },\n      onBeforeCompile: {\n        get: function get() {\n          return onBeforeCompile;\n        },\n        set: function set(fn) {\n          this[privateBeforeCompileProp] = fn;\n        }\n      },\n      copy: {\n        value: function value(source) {\n          baseMaterial.copy.call(this, source);\n          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n            this.extensions = assign({}, source.extensions);\n            this.defines = assign({}, source.defines);\n            this.uniforms = three.UniformsUtils.clone(source.uniforms);\n          }\n          return this;\n        }\n      },\n      /**\n       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDepthMaterial: {\n        value: function value() {\n          var depthMaterial = this._depthMaterial;\n          if (!depthMaterial) {\n            if (!depthMaterialTpl) {\n              depthMaterialTpl = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new three.MeshDepthMaterial({\n                depthPacking: three.RGBADepthPacking\n              }), options);\n              depthMaterialTpl.defines.IS_DEPTH_MATERIAL = '';\n            }\n            depthMaterial = this._depthMaterial = depthMaterialTpl.clone();\n            depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n\n          return depthMaterial;\n        }\n      },\n      /**\n       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDistanceMaterial: {\n        value: function value() {\n          var distanceMaterial = this._distanceMaterial;\n          if (!distanceMaterial) {\n            if (!distanceMaterialTpl) {\n              distanceMaterialTpl = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new three.MeshDistanceMaterial(), options);\n              distanceMaterialTpl.defines.IS_DISTANCE_MATERIAL = '';\n            }\n            distanceMaterial = this._distanceMaterial = distanceMaterialTpl.clone();\n            distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n\n          return distanceMaterial;\n        }\n      },\n      dispose: {\n        value: function value() {\n          var ref = this;\n          var _depthMaterial = ref._depthMaterial;\n          var _distanceMaterial = ref._distanceMaterial;\n          if (_depthMaterial) {\n            _depthMaterial.dispose();\n          }\n          if (_distanceMaterial) {\n            _distanceMaterial.dispose();\n          }\n          baseMaterial.dispose.call(this);\n        }\n      }\n    });\n    var material = new DerivedMaterial();\n    material.copy(baseMaterial);\n\n    // Merge uniforms, defines, and extensions\n    material.uniforms = assign(three.UniformsUtils.clone(baseMaterial.uniforms || {}), options.uniforms);\n    material.defines = assign({}, baseMaterial.defines, options.defines);\n    material.defines.TROIKA_DERIVED_MATERIAL = id; //force a program change from the base material\n    material.extensions = assign({}, baseMaterial.extensions, options.extensions);\n    cached[optionsHash] = material;\n    return material.clone(); //return a clone so changes made to it don't affect the cached object\n  }\n\n  function upgradeShaders(ref, options, id) {\n    var vertexShader = ref.vertexShader;\n    var fragmentShader = ref.fragmentShader;\n    var vertexDefs = options.vertexDefs;\n    var vertexMainIntro = options.vertexMainIntro;\n    var vertexMainOutro = options.vertexMainOutro;\n    var vertexTransform = options.vertexTransform;\n    var fragmentDefs = options.fragmentDefs;\n    var fragmentMainIntro = options.fragmentMainIntro;\n    var fragmentMainOutro = options.fragmentMainOutro;\n    var fragmentColorTransform = options.fragmentColorTransform;\n    var customRewriter = options.customRewriter;\n    var timeUniform = options.timeUniform;\n    vertexDefs = vertexDefs || '';\n    vertexMainIntro = vertexMainIntro || '';\n    vertexMainOutro = vertexMainOutro || '';\n    fragmentDefs = fragmentDefs || '';\n    fragmentMainIntro = fragmentMainIntro || '';\n    fragmentMainOutro = fragmentMainOutro || '';\n\n    // Expand includes if needed\n    if (vertexTransform || customRewriter) {\n      vertexShader = expandShaderIncludes(vertexShader);\n    }\n    if (fragmentColorTransform || customRewriter) {\n      // We need to be able to find postprocessing chunks after include expansion in order to\n      // put them after the fragmentColorTransform, so mark them with comments first. Even if\n      // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n      // so we still mark them.\n      fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n');\n      fragmentShader = expandShaderIncludes(fragmentShader);\n    }\n\n    // Apply custom rewriter function\n    if (customRewriter) {\n      var res = customRewriter({\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader\n      });\n      vertexShader = res.vertexShader;\n      fragmentShader = res.fragmentShader;\n    }\n\n    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n    if (fragmentColorTransform) {\n      var postChunks = [];\n      fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm,\n      // [^]+? = non-greedy match of any chars including newlines\n      function (match) {\n        postChunks.push(match);\n        return '';\n      });\n      fragmentMainOutro = fragmentColorTransform + \"\\n\" + postChunks.join('\\n') + \"\\n\" + fragmentMainOutro;\n    }\n\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n      var code = \"\\nuniform float \" + timeUniform + \";\\n\";\n      vertexDefs = code + vertexDefs;\n      fragmentDefs = code + fragmentDefs;\n    }\n\n    // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n    if (vertexTransform) {\n      vertexDefs = vertexDefs + \"\\nvec3 troika_position_\" + id + \";\\nvec3 troika_normal_\" + id + \";\\nvec2 troika_uv_\" + id + \";\\nvoid troikaVertexTransform\" + id + \"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \" + vertexTransform + \"\\n}\\n\";\n      vertexMainIntro = \"\\ntroika_position_\" + id + \" = vec3(position);\\ntroika_normal_\" + id + \" = vec3(normal);\\ntroika_uv_\" + id + \" = vec2(uv);\\ntroikaVertexTransform\" + id + \"(troika_position_\" + id + \", troika_normal_\" + id + \", troika_uv_\" + id + \");\\n\" + vertexMainIntro + \"\\n\";\n      vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n        return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : \"troika_\" + match1 + \"_\" + id;\n      });\n    }\n\n    // Inject defs and intro/outro snippets\n    vertexShader = injectIntoShaderCode(vertexShader, id, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, id, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n    return {\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    };\n  }\n  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n      shaderCode = shaderCode.replace(voidMainRegExp, \"\\n\" + defs + \"\\nvoid troikaOrigMain\" + id + \"() {\");\n      shaderCode += \"\\nvoid main() {\\n  \" + intro + \"\\n  troikaOrigMain\" + id + \"();\\n  \" + outro + \"\\n}\";\n    }\n    return shaderCode;\n  }\n  function getOptionsHash(options) {\n    return JSON.stringify(options, optionsJsonReplacer);\n  }\n  function optionsJsonReplacer(key, value) {\n    return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\n  }\n\n  // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n  // TODO how can we keep this from getting stale?\n  var MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'phong',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n\n  /**\n   * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n   * used to render that material.\n   *\n   * @param material - the Material instance\n   * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n   */\n  function getShadersForMaterial(material) {\n    var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three.ShaderLib[builtinType] : material; //TODO fallback for unknown type?\n  }\n\n  /**\n   * Find all uniforms and their types within a shader code string.\n   *\n   * @param {string} shader - The shader code to parse\n   * @return {object} mapping of uniform names to their glsl type\n   */\n  function getShaderUniformTypes(shader) {\n    var uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n    var uniforms = Object.create(null);\n    var match;\n    while ((match = uniformRE.exec(shader)) !== null) {\n      uniforms[match[2]] = match[1];\n    }\n    return uniforms;\n  }\n\n  /**\n   * @class ShaderFloatArray\n   *\n   * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\n   * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\n   * because:\n   *\n   *   - GLSL \"array\" uniforms can only be of a constant length.\n   *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\n   *     extension is available.\n   *\n   * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\n   * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\n   * and GLSL code for you to put in your custom shader to query the float values by array index.\n   *\n   * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\n   * only allow texture lookups in fragment shaders.\n   *\n   * TODO:\n   *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits\n   *   - Use a float texture if the extension is available so we can skip the encoding process\n   */\n  var ShaderFloatArray = function ShaderFloatArray(name) {\n    this.name = name;\n    this.textureUniform = \"dataTex_\" + name;\n    this.textureSizeUniform = \"dataTexSize_\" + name;\n    this.multiplierUniform = \"dataMultiplier_\" + name;\n\n    /**\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\n     * length of the data array.\n     * @type {string}\n     */\n    this.dataSizeUniform = \"dataSize_\" + name;\n\n    /**\n     * @property readFunction - the name of the GLSL function that should be called to\n     * read data out of the array by index.\n     * @type {string}\n     */\n    this.readFunction = \"readData_\" + name;\n    this._raw = new Float32Array(0);\n    this._texture = new three.DataTexture(new Uint8Array(0), 0, 1);\n    this._length = 0;\n    this._multiplier = 1;\n  };\n  var prototypeAccessors = {\n    length: {\n      configurable: true\n    }\n  };\n\n  /**\n   * @property length - the current length of the data array\n   * @type {number}\n   */\n  prototypeAccessors.length.set = function (value) {\n    if (value !== this._length) {\n      // Find nearest power-of-2 that holds the new length\n      var size = Math.pow(2, Math.ceil(Math.log2(value)));\n      var raw = this._raw;\n      if (size < raw.length) {\n        this._raw = raw.subarray(0, size);\n      } else if (size > raw.length) {\n        this._raw = new Float32Array(size);\n        this._raw.set(raw);\n      }\n      this._length = value;\n    }\n  };\n  prototypeAccessors.length.get = function () {\n    return this._length;\n  };\n\n  /**\n   * Add a value to the end of the data array\n   * @param {number} value\n   */\n  ShaderFloatArray.prototype.push = function push(value) {\n    return this.set(this.length++, value);\n  };\n\n  /**\n   * Replace the existing data with that from a new array\n   * @param {ArrayLike<number>} array\n   */\n  ShaderFloatArray.prototype.setArray = function setArray(array) {\n    this.length = array.length;\n    this._raw.set(array);\n    this._needsRepack = true;\n  };\n\n  /**\n   * Get the current value at index\n   * @param {number} index\n   * @return {number}\n   */\n  ShaderFloatArray.prototype.get = function get(index) {\n    return this._raw[index];\n  };\n  ShaderFloatArray.prototype.set = function set(index, value) {\n    if (index + 1 > this._length) {\n      this.length = index + 1;\n    }\n    if (value !== this._raw[index]) {\n      this._raw[index] = value;\n      encodeFloatToFourInts(value / this._multiplier, this._texture.image.data, index * 4);\n      this._needsMultCheck = true;\n    }\n  };\n\n  /**\n   * Make a copy of this ShaderFloatArray\n   * @return {ShaderFloatArray}\n   */\n  ShaderFloatArray.prototype.clone = function clone() {\n    var clone = new ShaderFloatArray(this.name);\n    clone.setArray(this._raw);\n    return clone;\n  };\n\n  /**\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\n   * @return {Object}\n   */\n  ShaderFloatArray.prototype.getShaderUniforms = function getShaderUniforms() {\n    var obj;\n    var me = this;\n    return obj = {}, obj[this.textureUniform] = {\n      get value() {\n        me._sync();\n        return me._texture;\n      }\n    }, obj[this.textureSizeUniform] = {\n      get value() {\n        me._sync();\n        return me._texture.image.width;\n      }\n    }, obj[this.dataSizeUniform] = {\n      get value() {\n        me._sync();\n        return me.length;\n      }\n    }, obj[this.multiplierUniform] = {\n      get value() {\n        me._sync();\n        return me._multiplier;\n      }\n    }, obj;\n  };\n\n  /**\n   * Retrieve the GLSL code that must be injected into the shader's definitions area to\n   * enable reading from the data array. This exposes a function with a name matching\n   * the {@link #readFunction} property, which other shader code can call to read values\n   * from the array by their index.\n   * @return {string}\n   */\n  ShaderFloatArray.prototype.getShaderHeaderCode = function getShaderHeaderCode() {\n    var ref = this;\n    var textureUniform = ref.textureUniform;\n    var textureSizeUniform = ref.textureSizeUniform;\n    var dataSizeUniform = ref.dataSizeUniform;\n    var multiplierUniform = ref.multiplierUniform;\n    var readFunction = ref.readFunction;\n    return \"\\nuniform sampler2D \" + textureUniform + \";\\nuniform float \" + textureSizeUniform + \";\\nuniform float \" + dataSizeUniform + \";\\nuniform float \" + multiplierUniform + \";\\n\\nfloat \" + readFunction + \"(float index) {\\n  vec2 texUV = vec2((index + 0.5) / \" + textureSizeUniform + \", 0.5);\\n  vec4 pixel = texture2D(\" + textureUniform + \", texUV);\\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * \" + multiplierUniform + \";\\n}\\n\";\n  };\n\n  /**\n   * @private Synchronize any pending changes to the underlying DataTexture\n   */\n  ShaderFloatArray.prototype._sync = function _sync() {\n    var tex = this._texture;\n    var raw = this._raw;\n    var needsRepack = this._needsRepack;\n\n    // If the size of the raw array changed, resize the texture to match\n    if (raw.length !== tex.image.width) {\n      tex.image = {\n        data: new Uint8Array(raw.length * 4),\n        width: raw.length,\n        height: 1\n      };\n      needsRepack = true;\n    }\n\n    // If the values changed, check the multiplier. This should be a value by which\n    // all the values are divided to constrain them to the [0,1] range required by\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\n    // maximum value for greatest accuracy.\n    if (needsRepack || this._needsMultCheck) {\n      var maxVal = this._raw.reduce(function (a, b) {\n        return Math.max(a, b);\n      }, 0);\n      var mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\n      if (mult !== this._multiplier) {\n        this._multiplier = mult;\n        needsRepack = true;\n      }\n      tex.needsUpdate = true;\n      this._needsMultCheck = false;\n    }\n\n    // If things changed in a way we need to repack, do so\n    if (needsRepack) {\n      for (var i = 0, len = raw.length, mult$1 = this._multiplier; i < len; i++) {\n        encodeFloatToFourInts(raw[i] / mult$1, tex.image.data, i * 4);\n      }\n      this._needsRepack = false;\n    }\n  };\n  Object.defineProperties(ShaderFloatArray.prototype, prototypeAccessors);\n\n  /**\n   * Encode a floating point number into a set of four 8-bit integers.\n   * Also see the companion decoder function #decodeFloatFromFourInts.\n   *\n   * This is adapted to JavaScript from the basic approach at\n   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n   * but writes out integers in the range 0-255 instead of floats in the range 0-1\n   * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\n   *\n   * Some precision will necessarily be lost during the encoding and decoding process.\n   * Testing shows that the maximum precision error is ~1.18e-10 which should be good\n   * enough for most cases.\n   *\n   * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\n   *        otherwise the results will be incorrect.\n   * @param {Array|Uint8Array} array - an array into which the four ints should be written\n   * @param {Number} startIndex - index in the output array at which to start writing the ints\n   * @return {Array|Uint8Array}\n   */\n  function encodeFloatToFourInts(value, array, startIndex) {\n    // This is adapted to JS from the basic approach at\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    // but writes to a Uint8Array instead of floats. Input values must be in\n    // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\n    var enc0 = 255 * value;\n    var enc1 = 255 * (enc0 % 1);\n    var enc2 = 255 * (enc1 % 1);\n    var enc3 = 255 * (enc2 % 1);\n    enc0 = enc0 & 255;\n    enc1 = enc1 & 255;\n    enc2 = enc2 & 255;\n    enc3 = Math.round(enc3) & 255;\n    array[startIndex] = enc0;\n    array[startIndex + 1] = enc1;\n    array[startIndex + 2] = enc2;\n    array[startIndex + 3] = enc3;\n    return array;\n  }\n\n  /*\n  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,\n  divided into a reasonable number of height segments.\n  */\n\n  var vertexDefs = \"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\";\n  var vertexTransform = \"\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\\"sideways\\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won't see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n\";\n  var fragmentDefs = \"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\";\n  var fragmentMainIntro = \"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\";\n\n  // Debugging: separate color for each of the 6 sides:\n  // const fragmentColorTransform = `\n  // float sideNum = floor(vUV.x * 6.0);\n  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n  //   vec3(1.0, 0.0, 1.0);\n  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n  // `\n\n  function createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(baseMaterial, {\n      uniforms: {\n        pointA: {\n          value: new three.Vector3()\n        },\n        controlA: {\n          value: new three.Vector3()\n        },\n        controlB: {\n          value: new three.Vector3()\n        },\n        pointB: {\n          value: new three.Vector3()\n        },\n        radius: {\n          value: 0.01\n        },\n        dashing: {\n          value: new three.Vector3()\n        } //on, off, offset\n      },\n\n      vertexDefs: vertexDefs,\n      vertexTransform: vertexTransform,\n      fragmentDefs: fragmentDefs,\n      fragmentMainIntro: fragmentMainIntro\n    });\n  }\n  var geometry = null;\n  var defaultBaseMaterial = new three.MeshStandardMaterial({\n    color: 0xffffff,\n    side: three.DoubleSide\n  });\n\n  /**\n   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n   * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n   * automatically.\n   *\n   * The cubiz bezier path is determined by its four `Vector3` properties:\n   * - `pointA`\n   * - `controlA`\n   * - `controlB`\n   * - `pointB`\n   *\n   * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n   *\n   * You can also give the tube a dashed appearance with two properties:\n   *\n   * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n   *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n   *   used as input to the cubic bezier function, not its visible length.)\n   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n   *\n   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n   * thicker tubes.\n   *\n   * TODO: proper geometry bounding sphere and raycasting\n   * TODO: allow control of the geometry's segment counts\n   */\n  var BezierMesh = /*@__PURE__*/function (Mesh) {\n    function BezierMesh() {\n      Mesh.call(this, BezierMesh.getGeometry(), defaultBaseMaterial);\n      this.pointA = new three.Vector3();\n      this.controlA = new three.Vector3();\n      this.controlB = new three.Vector3();\n      this.pointB = new three.Vector3();\n      this.radius = 0.01;\n      this.dashArray = new three.Vector2();\n      this.dashOffset = 0;\n\n      // TODO - disabling frustum culling until I figure out how to customize the\n      //  geometry's bounding sphere that gets used\n      this.frustumCulled = false;\n    }\n    if (Mesh) BezierMesh.__proto__ = Mesh;\n    BezierMesh.prototype = Object.create(Mesh && Mesh.prototype);\n    BezierMesh.prototype.constructor = BezierMesh;\n    var prototypeAccessors = {\n      material: {\n        configurable: true\n      },\n      customDepthMaterial: {\n        configurable: true\n      },\n      customDistanceMaterial: {\n        configurable: true\n      }\n    };\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    BezierMesh.getGeometry = function getGeometry() {\n      return geometry || (geometry = new three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n    };\n    prototypeAccessors.material.get = function () {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || defaultBaseMaterial;\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        if (derivedMaterial) {\n          derivedMaterial.dispose();\n        }\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial;\n    };\n    prototypeAccessors.material.set = function (baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    };\n\n    // Create and update material for shadows upon request:\n    prototypeAccessors.customDepthMaterial.get = function () {\n      return this.material.getDepthMaterial();\n    };\n    prototypeAccessors.customDistanceMaterial.get = function () {\n      return this.material.getDistanceMaterial();\n    };\n    BezierMesh.prototype.onBeforeRender = function onBeforeRender(shaderInfo) {\n      var ref = this.material;\n      var uniforms = ref.uniforms;\n      var ref$1 = this;\n      var pointA = ref$1.pointA;\n      var controlA = ref$1.controlA;\n      var controlB = ref$1.controlB;\n      var pointB = ref$1.pointB;\n      var radius = ref$1.radius;\n      var dashArray = ref$1.dashArray;\n      var dashOffset = ref$1.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    };\n    BezierMesh.prototype.raycast = function raycast(raycaster, intersects) {\n      // TODO - just fail for now\n    };\n    Object.defineProperties(BezierMesh.prototype, prototypeAccessors);\n    return BezierMesh;\n  }(three.Mesh);\n  exports.BezierMesh = BezierMesh;\n  exports.ShaderFloatArray = ShaderFloatArray;\n  exports.createDerivedMaterial = createDerivedMaterial;\n  exports.expandShaderIncludes = expandShaderIncludes;\n  exports.getShaderUniformTypes = getShaderUniformTypes;\n  exports.getShadersForMaterial = getShadersForMaterial;\n  exports.voidMainRegExp = voidMainRegExp;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","require","define","amd","self","troika_three_utils","THREE","three","voidMainRegExp","expandShaderIncludes","source","pattern","replace","match","include","chunk","ShaderChunk","assign","Object","arguments$1","arguments","target","i","len","length","prop","hasOwnProperty","idCtr","epoch","Date","now","CACHE","WeakMap","createDerivedMaterial","baseMaterial","options","optionsHash","getOptionsHash","cached","get","create","set","clone","id","privateDerivedShadersProp","privateBeforeCompileProp","distanceMaterialTpl","depthMaterialTpl","onBeforeCompile","shaderInfo","call","ref","vertex","fragment","vertexShader","fragmentShader","upgraded","upgradeShaders","result","uniforms","timeUniform","value","DerivedMaterial","constructor","apply","_listeners","undefined","prototype","isDerivedMaterial","fn","copy","isShaderMaterial","extensions","defines","UniformsUtils","getDepthMaterial","depthMaterial","_depthMaterial","MeshDepthMaterial","depthPacking","RGBADepthPacking","IS_DEPTH_MATERIAL","getDistanceMaterial","distanceMaterial","_distanceMaterial","MeshDistanceMaterial","IS_DISTANCE_MATERIAL","dispose","material","TROIKA_DERIVED_MATERIAL","vertexDefs","vertexMainIntro","vertexMainOutro","vertexTransform","fragmentDefs","fragmentMainIntro","fragmentMainOutro","fragmentColorTransform","customRewriter","res","postChunks","push","join","code","match1","index","fullStr","test","substr","injectIntoShaderCode","shaderCode","defs","intro","outro","JSON","stringify","optionsJsonReplacer","key","toString","MATERIAL_TYPES_TO_SHADERS","MeshNormalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshStandardMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","getShadersForMaterial","builtinType","type","ShaderLib","getShaderUniformTypes","shader","uniformRE","exec","ShaderFloatArray","name","textureUniform","textureSizeUniform","multiplierUniform","dataSizeUniform","readFunction","_raw","Float32Array","_texture","DataTexture","Uint8Array","_length","_multiplier","prototypeAccessors","configurable","size","Math","pow","ceil","log2","raw","subarray","setArray","array","_needsRepack","encodeFloatToFourInts","image","data","_needsMultCheck","getShaderUniforms","obj","me","_sync","width","getShaderHeaderCode","tex","needsRepack","height","maxVal","reduce","a","b","max","mult","needsUpdate","mult$1","defineProperties","startIndex","enc0","enc1","enc2","enc3","round","createBezierMeshMaterial","pointA","Vector3","controlA","controlB","pointB","radius","dashing","geometry","defaultBaseMaterial","color","side","DoubleSide","BezierMesh","Mesh","getGeometry","dashArray","Vector2","dashOffset","frustumCulled","__proto__","customDepthMaterial","customDistanceMaterial","CylinderBufferGeometry","translate","derivedMaterial","_derivedMaterial","_baseMaterial","addEventListener","onDispose","removeEventListener","onBeforeRender","ref$1","x","y","raycast","raycaster","intersects","defineProperty"],"sources":["/Users/mac/Desktop/react-3js-word-sphere/node_modules/troika-three-utils/dist/troika-three-utils.umd.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) :\n  (global = global || self, factory(global.troika_three_utils = {}, global.THREE));\n}(this, (function (exports, three) { 'use strict';\n\n  /**\n   * Regular expression for matching the `void main() {` opener line in GLSL.\n   * @type {RegExp}\n   */\n  var voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n  /**\n   * Recursively expands all `#include <xyz>` statements within string of shader code.\n   * Copied from three's WebGLProgram#parseIncludes for external use.\n   *\n   * @param {string} source - The GLSL source code to evaluate\n   * @return {string} The GLSL code with all includes expanded\n   */\n  function expandShaderIncludes( source ) {\n    var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n      var chunk = three.ShaderChunk[include];\n      return chunk ? expandShaderIncludes(chunk) : match\n    }\n    return source.replace( pattern, replace )\n  }\n\n  // Local assign polyfill to avoid importing troika-core\n  var assign = Object.assign || function(/*target, ...sources*/) {\n    var arguments$1 = arguments;\n\n    var target = arguments[0];\n    for (var i = 1, len = arguments.length; i < len; i++) {\n      var source = arguments$1[i];\n      if (source) {\n        for (var prop in source) {\n          if (source.hasOwnProperty(prop)) {\n            target[prop] = source[prop];\n          }\n        }\n      }\n    }\n    return target\n  };\n\n\n  var idCtr = 0;\n  var epoch = Date.now();\n  var CACHE = new WeakMap(); //threejs requires WeakMap internally so should be safe to assume support\n\n\n  /**\n   * A utility for creating a custom shader material derived from another material's\n   * shaders. This allows you to inject custom shader logic and transforms into the\n   * builtin ThreeJS materials without having to recreate them from scratch.\n   *\n   * @param {THREE.Material} baseMaterial - the original material to derive from\n   *\n   * @param {Object} options - How the base material should be modified.\n   * @param {Object} options.defines - Custom `defines` for the material\n   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n   *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n   *        both shaders, and it will automatically be updated on each render frame with a number of\n   *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n   *        true calendar time.\n   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n   *        those attributes exposed by their normal names as read/write values.\n   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n   *        shader's `void main` function.\n   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n   *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n   *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n   *        want those to apply to your changes use `fragmentColorTransform` instead.\n   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n   *        output value. Will be injected near the end of the `void main` function, but before any\n   *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n   *        `fragmentMainOutro`.\n   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n   *        for performing custom rewrites of the full shader code. Useful if you need to do something\n   *        special that's not covered by the other builtin options. This function will be executed before\n   *        any other transforms are applied.\n   *\n   * @return {THREE.Material}\n   *\n   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n   * which can be called to get a variant of the derived material for use in shadow casting. If the\n   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n   * scenarios, e.g. skipping antialiasing or expensive shader logic.\n   */\n  function createDerivedMaterial(baseMaterial, options) {\n    // First check the cache to see if we've already derived from this baseMaterial using\n    // this unique set of options, and if so just return a clone instead of a new subclass\n    // which is faster and allows their shader program to be shared when rendering.\n    var optionsHash = getOptionsHash(options);\n    var cached = CACHE.get(baseMaterial);\n    if (!cached) {\n      cached = Object.create(null);\n      CACHE.set(baseMaterial, cached);\n    }\n    if (cached[optionsHash]) {\n      return cached[optionsHash].clone()\n    }\n\n    var id = ++idCtr;\n    var privateDerivedShadersProp = \"_derivedShaders\" + id;\n    var privateBeforeCompileProp = \"_onBeforeCompile\" + id;\n    var distanceMaterialTpl, depthMaterialTpl;\n\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n    function onBeforeCompile(shaderInfo) {\n      baseMaterial.onBeforeCompile.call(this, shaderInfo);\n\n      // Upgrade the shaders, caching the result\n      var ref = this[privateDerivedShadersProp] || (this[privateDerivedShadersProp] = {vertex: {}, fragment: {}});\n      var vertex = ref.vertex;\n      var fragment = ref.fragment;\n      if (vertex.source !== shaderInfo.vertexShader || fragment.source !== shaderInfo.fragmentShader) {\n        var upgraded = upgradeShaders(shaderInfo, options, id);\n        vertex.source = shaderInfo.vertexShader;\n        vertex.result = upgraded.vertexShader;\n        fragment.source = shaderInfo.fragmentShader;\n        fragment.result = upgraded.fragmentShader;\n      }\n\n      // Inject upgraded shaders and uniforms into the program\n      shaderInfo.vertexShader = vertex.result;\n      shaderInfo.fragmentShader = fragment.result;\n      assign(shaderInfo.uniforms, this.uniforms);\n\n      // Inject auto-updating time uniform if requested\n      if (options.timeUniform) {\n        shaderInfo.uniforms[options.timeUniform] = {\n          get value() {return Date.now() - epoch}\n        };\n      }\n\n      // Users can still add their own handlers on top of ours\n      if (this[privateBeforeCompileProp]) {\n        this[privateBeforeCompileProp](shaderInfo);\n      }\n    }\n\n    function DerivedMaterial() {\n      baseMaterial.constructor.apply(this, arguments);\n      this._listeners = undefined; //don't inherit EventDispatcher listeners\n    }\n    DerivedMaterial.prototype = Object.create(baseMaterial, {\n      constructor: {value: DerivedMaterial},\n      isDerivedMaterial: {value: true},\n      baseMaterial: {value: baseMaterial},\n\n      onBeforeCompile: {\n        get: function get() {\n          return onBeforeCompile\n        },\n        set: function set(fn) {\n          this[privateBeforeCompileProp] = fn;\n        }\n      },\n\n      copy: {\n        value: function (source) {\n          baseMaterial.copy.call(this, source);\n          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n            this.extensions = assign({}, source.extensions);\n            this.defines = assign({}, source.defines);\n            this.uniforms = three.UniformsUtils.clone(source.uniforms);\n          }\n          return this\n        }\n      },\n\n      /**\n       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDepthMaterial: {value: function() {\n        var depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          if (!depthMaterialTpl) {\n            depthMaterialTpl = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDepthMaterial()\n                : new three.MeshDepthMaterial({depthPacking: three.RGBADepthPacking}),\n              options\n            );\n            depthMaterialTpl.defines.IS_DEPTH_MATERIAL = '';\n          }\n          depthMaterial = this._depthMaterial = depthMaterialTpl.clone();\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }},\n\n      /**\n       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDistanceMaterial: {value: function() {\n        var distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          if (!distanceMaterialTpl) {\n            distanceMaterialTpl = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDistanceMaterial()\n                : new three.MeshDistanceMaterial(),\n              options\n            );\n            distanceMaterialTpl.defines.IS_DISTANCE_MATERIAL = '';\n          }\n          distanceMaterial = this._distanceMaterial = distanceMaterialTpl.clone();\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }},\n\n      dispose: {value: function value() {\n        var ref = this;\n        var _depthMaterial = ref._depthMaterial;\n        var _distanceMaterial = ref._distanceMaterial;\n        if (_depthMaterial) { _depthMaterial.dispose(); }\n        if (_distanceMaterial) { _distanceMaterial.dispose(); }\n        baseMaterial.dispose.call(this);\n      }}\n    });\n\n    var material = new DerivedMaterial();\n    material.copy(baseMaterial);\n\n    // Merge uniforms, defines, and extensions\n    material.uniforms = assign(three.UniformsUtils.clone(baseMaterial.uniforms || {}), options.uniforms);\n    material.defines = assign({}, baseMaterial.defines, options.defines);\n    material.defines.TROIKA_DERIVED_MATERIAL = id; //force a program change from the base material\n    material.extensions = assign({}, baseMaterial.extensions, options.extensions);\n\n    cached[optionsHash] = material;\n    return material.clone() //return a clone so changes made to it don't affect the cached object\n  }\n\n\n  function upgradeShaders(ref, options, id) {\n    var vertexShader = ref.vertexShader;\n    var fragmentShader = ref.fragmentShader;\n\n    var vertexDefs = options.vertexDefs;\n    var vertexMainIntro = options.vertexMainIntro;\n    var vertexMainOutro = options.vertexMainOutro;\n    var vertexTransform = options.vertexTransform;\n    var fragmentDefs = options.fragmentDefs;\n    var fragmentMainIntro = options.fragmentMainIntro;\n    var fragmentMainOutro = options.fragmentMainOutro;\n    var fragmentColorTransform = options.fragmentColorTransform;\n    var customRewriter = options.customRewriter;\n    var timeUniform = options.timeUniform;\n\n    vertexDefs = vertexDefs || '';\n    vertexMainIntro = vertexMainIntro || '';\n    vertexMainOutro = vertexMainOutro || '';\n    fragmentDefs = fragmentDefs || '';\n    fragmentMainIntro = fragmentMainIntro || '';\n    fragmentMainOutro = fragmentMainOutro || '';\n\n    // Expand includes if needed\n    if (vertexTransform || customRewriter) {\n      vertexShader = expandShaderIncludes(vertexShader);\n    }\n    if (fragmentColorTransform || customRewriter) {\n      // We need to be able to find postprocessing chunks after include expansion in order to\n      // put them after the fragmentColorTransform, so mark them with comments first. Even if\n      // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n      // so we still mark them.\n      fragmentShader = fragmentShader.replace(\n        /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n        '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n      );\n      fragmentShader = expandShaderIncludes(fragmentShader);\n    }\n\n    // Apply custom rewriter function\n    if (customRewriter) {\n      var res = customRewriter({vertexShader: vertexShader, fragmentShader: fragmentShader});\n      vertexShader = res.vertexShader;\n      fragmentShader = res.fragmentShader;\n    }\n\n    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n    if (fragmentColorTransform) {\n      var postChunks = [];\n      fragmentShader = fragmentShader.replace(\n        /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n        function (match) {\n          postChunks.push(match);\n          return ''\n        }\n      );\n      fragmentMainOutro = fragmentColorTransform + \"\\n\" + (postChunks.join('\\n')) + \"\\n\" + fragmentMainOutro;\n    }\n\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n      var code = \"\\nuniform float \" + timeUniform + \";\\n\";\n      vertexDefs = code + vertexDefs;\n      fragmentDefs = code + fragmentDefs;\n    }\n\n    // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n    if (vertexTransform) {\n      vertexDefs = vertexDefs + \"\\nvec3 troika_position_\" + id + \";\\nvec3 troika_normal_\" + id + \";\\nvec2 troika_uv_\" + id + \";\\nvoid troikaVertexTransform\" + id + \"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \" + vertexTransform + \"\\n}\\n\";\n      vertexMainIntro = \"\\ntroika_position_\" + id + \" = vec3(position);\\ntroika_normal_\" + id + \" = vec3(normal);\\ntroika_uv_\" + id + \" = vec2(uv);\\ntroikaVertexTransform\" + id + \"(troika_position_\" + id + \", troika_normal_\" + id + \", troika_uv_\" + id + \");\\n\" + vertexMainIntro + \"\\n\";\n      vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n        return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : (\"troika_\" + match1 + \"_\" + id)\n      });\n    }\n\n    // Inject defs and intro/outro snippets\n    vertexShader = injectIntoShaderCode(vertexShader, id, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, id, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n    return {\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    }\n  }\n\n  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n      shaderCode = shaderCode.replace(voidMainRegExp, (\"\\n\" + defs + \"\\nvoid troikaOrigMain\" + id + \"() {\")\n      );\n      shaderCode += \"\\nvoid main() {\\n  \" + intro + \"\\n  troikaOrigMain\" + id + \"();\\n  \" + outro + \"\\n}\";\n    }\n    return shaderCode\n  }\n\n  function getOptionsHash(options) {\n    return JSON.stringify(options, optionsJsonReplacer)\n  }\n\n  function optionsJsonReplacer(key, value) {\n    return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n  }\n\n  // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n  // TODO how can we keep this from getting stale?\n  var MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'phong',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n\n  /**\n   * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n   * used to render that material.\n   *\n   * @param material - the Material instance\n   * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n   */\n  function getShadersForMaterial(material) {\n    var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n  }\n\n  /**\n   * Find all uniforms and their types within a shader code string.\n   *\n   * @param {string} shader - The shader code to parse\n   * @return {object} mapping of uniform names to their glsl type\n   */\n  function getShaderUniformTypes(shader) {\n    var uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n    var uniforms = Object.create(null);\n    var match;\n    while ((match = uniformRE.exec(shader)) !== null) {\n      uniforms[match[2]] = match[1];\n    }\n    return uniforms\n  }\n\n  /**\n   * @class ShaderFloatArray\n   *\n   * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\n   * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\n   * because:\n   *\n   *   - GLSL \"array\" uniforms can only be of a constant length.\n   *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\n   *     extension is available.\n   *\n   * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\n   * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\n   * and GLSL code for you to put in your custom shader to query the float values by array index.\n   *\n   * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\n   * only allow texture lookups in fragment shaders.\n   *\n   * TODO:\n   *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits\n   *   - Use a float texture if the extension is available so we can skip the encoding process\n   */\n  var ShaderFloatArray = function ShaderFloatArray(name) {\n    this.name = name;\n    this.textureUniform = \"dataTex_\" + name;\n    this.textureSizeUniform = \"dataTexSize_\" + name;\n    this.multiplierUniform = \"dataMultiplier_\" + name;\n\n    /**\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\n     * length of the data array.\n     * @type {string}\n     */\n    this.dataSizeUniform = \"dataSize_\" + name;\n\n    /**\n     * @property readFunction - the name of the GLSL function that should be called to\n     * read data out of the array by index.\n     * @type {string}\n     */\n    this.readFunction = \"readData_\" + name;\n\n    this._raw = new Float32Array(0);\n    this._texture = new three.DataTexture(new Uint8Array(0), 0, 1);\n    this._length = 0;\n    this._multiplier = 1;\n  };\n\n  var prototypeAccessors = { length: { configurable: true } };\n\n  /**\n   * @property length - the current length of the data array\n   * @type {number}\n   */\n  prototypeAccessors.length.set = function (value) {\n    if (value !== this._length) {\n      // Find nearest power-of-2 that holds the new length\n      var size = Math.pow(2, Math.ceil(Math.log2(value)));\n      var raw = this._raw;\n      if (size < raw.length) {\n        this._raw = raw.subarray(0, size);\n      }\n      else if(size > raw.length) {\n        this._raw = new Float32Array(size);\n        this._raw.set(raw);\n      }\n      this._length = value;\n    }\n  };\n  prototypeAccessors.length.get = function () {\n    return this._length\n  };\n\n  /**\n   * Add a value to the end of the data array\n   * @param {number} value\n   */\n  ShaderFloatArray.prototype.push = function push (value) {\n    return this.set(this.length++, value)\n  };\n\n  /**\n   * Replace the existing data with that from a new array\n   * @param {ArrayLike<number>} array\n   */\n  ShaderFloatArray.prototype.setArray = function setArray (array) {\n    this.length = array.length;\n    this._raw.set(array);\n    this._needsRepack = true;\n  };\n\n  /**\n   * Get the current value at index\n   * @param {number} index\n   * @return {number}\n   */\n  ShaderFloatArray.prototype.get = function get (index) {\n    return this._raw[index]\n  };\n\n  ShaderFloatArray.prototype.set = function set (index, value) {\n    if (index + 1 > this._length) {\n      this.length = index + 1;\n    }\n    if (value !== this._raw[index]) {\n      this._raw[index] = value;\n      encodeFloatToFourInts(\n        value / this._multiplier,\n        this._texture.image.data,\n        index * 4\n      );\n      this._needsMultCheck = true;\n    }\n  };\n\n  /**\n   * Make a copy of this ShaderFloatArray\n   * @return {ShaderFloatArray}\n   */\n  ShaderFloatArray.prototype.clone = function clone () {\n    var clone = new ShaderFloatArray(this.name);\n    clone.setArray(this._raw);\n    return clone\n  };\n\n  /**\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\n   * @return {Object}\n   */\n  ShaderFloatArray.prototype.getShaderUniforms = function getShaderUniforms () {\n      var obj;\n\n    var me = this;\n    return ( obj = {}, obj[this.textureUniform] = {get value() {\n        me._sync();\n        return me._texture\n      }}, obj[this.textureSizeUniform] = {get value() {\n        me._sync();\n        return me._texture.image.width\n      }}, obj[this.dataSizeUniform] = {get value() {\n        me._sync();\n        return me.length\n      }}, obj[this.multiplierUniform] = {get value() {\n        me._sync();\n        return me._multiplier\n      }}, obj )\n  };\n\n  /**\n   * Retrieve the GLSL code that must be injected into the shader's definitions area to\n   * enable reading from the data array. This exposes a function with a name matching\n   * the {@link #readFunction} property, which other shader code can call to read values\n   * from the array by their index.\n   * @return {string}\n   */\n  ShaderFloatArray.prototype.getShaderHeaderCode = function getShaderHeaderCode () {\n    var ref = this;\n      var textureUniform = ref.textureUniform;\n      var textureSizeUniform = ref.textureSizeUniform;\n      var dataSizeUniform = ref.dataSizeUniform;\n      var multiplierUniform = ref.multiplierUniform;\n      var readFunction = ref.readFunction;\n    return (\"\\nuniform sampler2D \" + textureUniform + \";\\nuniform float \" + textureSizeUniform + \";\\nuniform float \" + dataSizeUniform + \";\\nuniform float \" + multiplierUniform + \";\\n\\nfloat \" + readFunction + \"(float index) {\\n  vec2 texUV = vec2((index + 0.5) / \" + textureSizeUniform + \", 0.5);\\n  vec4 pixel = texture2D(\" + textureUniform + \", texUV);\\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * \" + multiplierUniform + \";\\n}\\n\")\n  };\n\n  /**\n   * @private Synchronize any pending changes to the underlying DataTexture\n   */\n  ShaderFloatArray.prototype._sync = function _sync () {\n    var tex = this._texture;\n    var raw = this._raw;\n    var needsRepack = this._needsRepack;\n\n    // If the size of the raw array changed, resize the texture to match\n    if (raw.length !== tex.image.width) {\n      tex.image = {\n        data: new Uint8Array(raw.length * 4),\n        width: raw.length,\n        height: 1\n      };\n      needsRepack = true;\n    }\n\n    // If the values changed, check the multiplier. This should be a value by which\n    // all the values are divided to constrain them to the [0,1] range required by\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\n    // maximum value for greatest accuracy.\n    if (needsRepack || this._needsMultCheck) {\n      var maxVal = this._raw.reduce(function (a, b) { return Math.max(a, b); }, 0);\n      var mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\n      if (mult !== this._multiplier) {\n        this._multiplier = mult;\n        needsRepack = true;\n      }\n      tex.needsUpdate = true;\n      this._needsMultCheck = false;\n    }\n\n    // If things changed in a way we need to repack, do so\n    if (needsRepack) {\n      for (var i = 0, len = raw.length, mult$1 = this._multiplier; i < len; i++) {\n        encodeFloatToFourInts(raw[i] / mult$1, tex.image.data, i * 4);\n      }\n      this._needsRepack = false;\n    }\n  };\n\n  Object.defineProperties( ShaderFloatArray.prototype, prototypeAccessors );\n\n\n\n  /**\n   * Encode a floating point number into a set of four 8-bit integers.\n   * Also see the companion decoder function #decodeFloatFromFourInts.\n   *\n   * This is adapted to JavaScript from the basic approach at\n   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n   * but writes out integers in the range 0-255 instead of floats in the range 0-1\n   * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\n   *\n   * Some precision will necessarily be lost during the encoding and decoding process.\n   * Testing shows that the maximum precision error is ~1.18e-10 which should be good\n   * enough for most cases.\n   *\n   * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\n   *        otherwise the results will be incorrect.\n   * @param {Array|Uint8Array} array - an array into which the four ints should be written\n   * @param {Number} startIndex - index in the output array at which to start writing the ints\n   * @return {Array|Uint8Array}\n   */\n  function encodeFloatToFourInts(value, array, startIndex) {\n    // This is adapted to JS from the basic approach at\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n    // but writes to a Uint8Array instead of floats. Input values must be in\n    // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\n    var enc0 = 255 * value;\n    var enc1 = 255 * (enc0 % 1);\n    var enc2 = 255 * (enc1 % 1);\n    var enc3 = 255 * (enc2 % 1);\n\n    enc0 = enc0 & 255;\n    enc1 = enc1 & 255;\n    enc2 = enc2 & 255;\n    enc3 = Math.round(enc3) & 255;\n\n    array[startIndex] = enc0;\n    array[startIndex + 1] = enc1;\n    array[startIndex + 2] = enc2;\n    array[startIndex + 3] = enc3;\n    return array\n  }\n\n  /*\n  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,\n  divided into a reasonable number of height segments.\n  */\n\n  var vertexDefs = \"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\";\n\n  var vertexTransform = \"\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\\"sideways\\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won't see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n\";\n\n  var fragmentDefs = \"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\";\n\n  var fragmentMainIntro = \"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\";\n\n  // Debugging: separate color for each of the 6 sides:\n  // const fragmentColorTransform = `\n  // float sideNum = floor(vUV.x * 6.0);\n  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n  //   vec3(1.0, 0.0, 1.0);\n  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n  // `\n\n\n\n  function createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(\n      baseMaterial,\n      {\n        uniforms: {\n          pointA: {value: new three.Vector3()},\n          controlA: {value: new three.Vector3()},\n          controlB: {value: new three.Vector3()},\n          pointB: {value: new three.Vector3()},\n          radius: {value: 0.01},\n          dashing: {value: new three.Vector3()} //on, off, offset\n        },\n        vertexDefs: vertexDefs,\n        vertexTransform: vertexTransform,\n        fragmentDefs: fragmentDefs,\n        fragmentMainIntro: fragmentMainIntro\n      }\n    )\n  }\n\n  var geometry = null;\n\n  var defaultBaseMaterial = new three.MeshStandardMaterial({color: 0xffffff, side: three.DoubleSide});\n\n\n  /**\n   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n   * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n   * automatically.\n   *\n   * The cubiz bezier path is determined by its four `Vector3` properties:\n   * - `pointA`\n   * - `controlA`\n   * - `controlB`\n   * - `pointB`\n   *\n   * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n   *\n   * You can also give the tube a dashed appearance with two properties:\n   *\n   * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n   *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n   *   used as input to the cubic bezier function, not its visible length.)\n   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n   *\n   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n   * thicker tubes.\n   *\n   * TODO: proper geometry bounding sphere and raycasting\n   * TODO: allow control of the geometry's segment counts\n   */\n  var BezierMesh = /*@__PURE__*/(function (Mesh) {\n    function BezierMesh() {\n      Mesh.call(\n        this, BezierMesh.getGeometry(),\n        defaultBaseMaterial\n      );\n\n      this.pointA = new three.Vector3();\n      this.controlA = new three.Vector3();\n      this.controlB = new three.Vector3();\n      this.pointB = new three.Vector3();\n      this.radius = 0.01;\n      this.dashArray = new three.Vector2();\n      this.dashOffset = 0;\n\n      // TODO - disabling frustum culling until I figure out how to customize the\n      //  geometry's bounding sphere that gets used\n      this.frustumCulled = false;\n    }\n\n    if ( Mesh ) BezierMesh.__proto__ = Mesh;\n    BezierMesh.prototype = Object.create( Mesh && Mesh.prototype );\n    BezierMesh.prototype.constructor = BezierMesh;\n\n    var prototypeAccessors = { material: { configurable: true },customDepthMaterial: { configurable: true },customDistanceMaterial: { configurable: true } };\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    BezierMesh.getGeometry = function getGeometry () {\n      return geometry || (geometry =\n        new three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n      )\n    };\n\n    prototypeAccessors.material.get = function () {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || defaultBaseMaterial;\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        if (derivedMaterial) {\n          derivedMaterial.dispose();\n        }\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial\n    };\n    prototypeAccessors.material.set = function (baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    };\n\n    // Create and update material for shadows upon request:\n    prototypeAccessors.customDepthMaterial.get = function () {\n      return this.material.getDepthMaterial()\n    };\n    prototypeAccessors.customDistanceMaterial.get = function () {\n      return this.material.getDistanceMaterial()\n    };\n\n    BezierMesh.prototype.onBeforeRender = function onBeforeRender (shaderInfo) {\n      var ref = this.material;\n      var uniforms = ref.uniforms;\n      var ref$1 = this;\n      var pointA = ref$1.pointA;\n      var controlA = ref$1.controlA;\n      var controlB = ref$1.controlB;\n      var pointB = ref$1.pointB;\n      var radius = ref$1.radius;\n      var dashArray = ref$1.dashArray;\n      var dashOffset = ref$1.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    };\n\n    BezierMesh.prototype.raycast = function raycast (raycaster, intersects) {\n      // TODO - just fail for now\n    };\n\n    Object.defineProperties( BezierMesh.prototype, prototypeAccessors );\n\n    return BezierMesh;\n  }(three.Mesh));\n\n  exports.BezierMesh = BezierMesh;\n  exports.ShaderFloatArray = ShaderFloatArray;\n  exports.createDerivedMaterial = createDerivedMaterial;\n  exports.expandShaderIncludes = expandShaderIncludes;\n  exports.getShaderUniformTypes = getShaderUniformTypes;\n  exports.getShadersForMaterial = getShadersForMaterial;\n  exports.voidMainRegExp = voidMainRegExp;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}