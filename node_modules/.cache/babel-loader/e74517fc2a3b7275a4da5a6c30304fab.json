{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.troika_worker_utils = {}));\n})(this, function (exports) {\n  'use strict';\n\n  /**\n   * Lightweight thenable implementation that is entirely self-contained within a single\n   * function with no external dependencies so it can be easily shipped across to a WorkerModule.\n   *\n   * This implementation conforms fully to the Promises/A+ spec so it can safely interoperate\n   * with other thenable implementations. https://github.com/promises-aplus/promises-spec\n   *\n   * *However*, it is _not_ a full implementation of ES2015 Promises, e.g. it does not\n   * have the same constructor signature and does not expose a `catch` method or the static\n   * `resolve`/`reject`/`all`/`race` initializer methods. If you need to hand a Thenable\n   * instance off to consuming code that may expect a true Promise, you'll want to wrap it\n   * in a native-or-polyfilled Promise first.\n   *\n   * (Why yet another Promises/A+ implementation? Great question. We needed a polyfill-like\n   * thing that was (a) wrapped in a single function for easy serialization across to a Worker,\n   * and (b) was as small as possible -- at ~900B minified (~500B gzipped) this is the smallest\n   * implementation I've found. And also, exercises like this are challenging and fun.)\n   */\n  function BespokeThenable() {\n    var state = 0; // 0=pending, 1=fulfilled, -1=rejected\n    var queue = [];\n    var value;\n    var scheduled = 0;\n    var completeCalled = 0;\n    function then(onResolve, onReject) {\n      var nextThenable = BespokeThenable();\n      function handleNext() {\n        var cb = state > 0 ? onResolve : onReject;\n        if (isFn(cb)) {\n          try {\n            var result = cb(value);\n            if (result === nextThenable) {\n              recursiveError();\n            }\n            var resultThen = getThenableThen(result);\n            if (resultThen) {\n              resultThen.call(result, nextThenable.resolve, nextThenable.reject);\n            } else {\n              nextThenable.resolve(result);\n            }\n          } catch (err) {\n            nextThenable.reject(err);\n          }\n        } else {\n          nextThenable[state > 0 ? 'resolve' : 'reject'](value);\n        }\n      }\n      queue.push(handleNext);\n      if (state) {\n        scheduleQueueFlush();\n      }\n      return nextThenable;\n    }\n    var resolve = oneTime(function (val) {\n      if (!completeCalled) {\n        complete(1, val);\n      }\n    });\n    var reject = oneTime(function (reason) {\n      if (!completeCalled) {\n        complete(-1, reason);\n      }\n    });\n    function complete(st, val) {\n      completeCalled++;\n      var ignoreThrow = 0;\n      try {\n        if (val === thenableObj) {\n          recursiveError();\n        }\n        var valThen = st > 0 && getThenableThen(val);\n        if (valThen) {\n          valThen.call(val, oneTime(function (v) {\n            ignoreThrow++;\n            complete(1, v);\n          }), oneTime(function (v) {\n            ignoreThrow++;\n            complete(-1, v);\n          }));\n        } else {\n          state = st;\n          value = val;\n          scheduleQueueFlush();\n        }\n      } catch (e) {\n        if (!state && !ignoreThrow) {\n          complete(-1, e);\n        }\n      }\n    }\n    function scheduleQueueFlush() {\n      if (!scheduled) {\n        setTimeout(flushQueue, 0); //TODO setImmediate or postMessage approach if available?\n        scheduled = 1;\n      }\n    }\n    function flushQueue() {\n      var q = queue;\n      scheduled = 0;\n      queue = [];\n      q.forEach(callIt);\n    }\n    function callIt(fn) {\n      fn();\n    }\n    function getThenableThen(val) {\n      var valThen = val && (isFn(val) || typeof val === 'object') && val.then;\n      return isFn(valThen) && valThen;\n    }\n    function oneTime(fn) {\n      var called = 0;\n      return function () {\n        var args = [],\n          len = arguments.length;\n        while (len--) {\n          args[len] = arguments[len];\n        }\n        if (!called++) {\n          fn.apply(this, args);\n        }\n      };\n    }\n    function recursiveError() {\n      throw new TypeError('Chaining cycle detected');\n    }\n    var isFn = function isFn(v) {\n      return typeof v === 'function';\n    };\n    var thenableObj = {\n      then: then,\n      resolve: resolve,\n      reject: reject\n    };\n    return thenableObj;\n  }\n\n  /**\n   * Thenable implementation that uses a native Promise under the covers. This implementation\n   * is preferred if Promise is available, for better performance and dev tools integration.\n   * @constructor\n   */\n  function NativePromiseThenable() {\n    var resolve, reject;\n    var promise = new Promise(function (res, rej) {\n      resolve = res;\n      reject = rej;\n    });\n    return {\n      then: promise.then.bind(promise),\n      resolve: resolve,\n      reject: reject\n    };\n  }\n\n  /**\n   * Choose the best Thenable implementation and export it as the default.\n   */\n  var Thenable = typeof Promise === 'function' ? NativePromiseThenable : BespokeThenable;\n\n  /**\n   * Main content for the worker that handles the loading and execution of\n   * modules within it.\n   */\n  function workerBootstrap() {\n    var modules = Object.create(null);\n\n    // Handle messages for registering a module\n    function registerModule(ref, callback) {\n      var id = ref.id;\n      var name = ref.name;\n      var dependencies = ref.dependencies;\n      if (dependencies === void 0) dependencies = [];\n      var init = ref.init;\n      if (init === void 0) init = function init() {};\n      var getTransferables = ref.getTransferables;\n      if (getTransferables === void 0) getTransferables = null;\n\n      // Only register once\n      if (modules[id]) {\n        return;\n      }\n      try {\n        // If any dependencies are modules, ensure they're registered and grab their value\n        dependencies = dependencies.map(function (dep) {\n          if (dep && dep.isWorkerModule) {\n            registerModule(dep, function (depResult) {\n              if (depResult instanceof Error) {\n                throw depResult;\n              }\n            });\n            dep = modules[dep.id].value;\n          }\n          return dep;\n        });\n\n        // Rehydrate functions\n        init = rehydrate(\"<\" + name + \">.init\", init);\n        if (getTransferables) {\n          getTransferables = rehydrate(\"<\" + name + \">.getTransferables\", getTransferables);\n        }\n\n        // Initialize the module and store its value\n        var value = null;\n        if (typeof init === 'function') {\n          value = init.apply(void 0, dependencies);\n        } else {\n          console.error('worker module init function failed to rehydrate');\n        }\n        modules[id] = {\n          id: id,\n          value: value,\n          getTransferables: getTransferables\n        };\n        callback(value);\n      } catch (err) {\n        if (!(err && err.noLog)) {\n          console.error(err);\n        }\n        callback(err);\n      }\n    }\n\n    // Handle messages for calling a registered module's result function\n    function callModule(ref, callback) {\n      var ref$1;\n      var id = ref.id;\n      var args = ref.args;\n      if (!modules[id] || typeof modules[id].value !== 'function') {\n        callback(new Error(\"Worker module \" + id + \": not found or its 'init' did not return a function\"));\n      }\n      try {\n        var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n        if (result && typeof result.then === 'function') {\n          result.then(handleResult, function (rej) {\n            return callback(rej instanceof Error ? rej : new Error('' + rej));\n          });\n        } else {\n          handleResult(result);\n        }\n      } catch (err) {\n        callback(err);\n      }\n      function handleResult(result) {\n        try {\n          var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n          if (!tx || !Array.isArray(tx) || !tx.length) {\n            tx = undefined; //postMessage is very picky about not passing null or empty transferables\n          }\n\n          callback(result, tx);\n        } catch (err) {\n          console.error(err);\n          callback(err);\n        }\n      }\n    }\n    function rehydrate(name, str) {\n      var result = void 0;\n      self.troikaDefine = function (r) {\n        return result = r;\n      };\n      var url = URL.createObjectURL(new Blob([\"/** \" + name.replace(/\\*/g, '') + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\"], {\n        type: 'application/javascript'\n      }));\n      try {\n        importScripts(url);\n      } catch (err) {\n        console.error(err);\n      }\n      URL.revokeObjectURL(url);\n      delete self.troikaDefine;\n      return result;\n    }\n\n    // Handler for all messages within the worker\n    self.addEventListener('message', function (e) {\n      var ref = e.data;\n      var messageId = ref.messageId;\n      var action = ref.action;\n      var data = ref.data;\n      try {\n        // Module registration\n        if (action === 'registerModule') {\n          registerModule(data, function (result) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: {\n                  isCallable: typeof result === 'function'\n                }\n              });\n            }\n          });\n        }\n        // Invocation\n        if (action === 'callModule') {\n          callModule(data, function (result, transferables) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: result\n              }, transferables || undefined);\n            }\n          });\n        }\n      } catch (err) {\n        postMessage({\n          messageId: messageId,\n          success: false,\n          error: err.stack\n        });\n      }\n    });\n  }\n  var _workerModuleId = 0;\n  var _messageId = 0;\n  var _allowInitAsString = false;\n  var workers = Object.create(null);\n  var openRequests = Object.create(null);\n  openRequests._count = 0;\n\n  /**\n   * Define a module of code that will be executed with a web worker. This provides a simple\n   * interface for moving chunks of logic off the main thread, and managing their dependencies\n   * among one another.\n   *\n   * @param {object} options\n   * @param {function} options.init - The main function that initializes the module. This will be run\n   *        within the worker, and will be passed the resolved dependencies as arguments. Its\n   *        return value becomes the module's content, which can then be used by other modules\n   *        that depend on it. This function can perform any logic using those dependencies, but\n   *        must not depend on anything from its parent closures.\n   * @param {array} [options.dependencies] - Provides any dependencies required by the init function:\n   *        - Primitives like strings, numbers, booleans\n   *        - Raw functions; these will be stringified and rehydrated within the worker so they\n   *          must not depend on anything from their parent closures\n   *        - Other worker modules; these will be resolved within the worker, and therefore modules\n   *          that provide functions can be called without having to cross the worker/main thread\n   *          boundary.\n   * @param {function} [options.getTransferables] - An optional function that will be run in the worker\n   *        just before posting the response value from a module call back to the main thread.\n   *        It will be passed that response value, and if it returns an array then that will be\n   *        used as the \"transferables\" parameter to `postMessage`. Use this if there are values\n   *        in the response that can/should be transfered rather than cloned.\n   * @param {string} [options.name] - A descriptive name for this module; this can be useful for\n   *        debugging but is not currently used for anything else.\n   * @param {string} [options.workerId] - By default all modules will run in the same dedicated worker,\n   *        but if you want to use multiple workers you can pass a `workerId` to indicate a specific\n   *        worker to spawn. Note that each worker is completely standalone and no data or state will\n   *        be shared between them. If a worker module is used as a dependency by worker modules\n   *        using different `workerId`s, then that dependency will be re-registered in each worker.\n   * @return {function(...[*]): {then}}\n   */\n  function defineWorkerModule(options) {\n    if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n      throw new Error('requires `options.init` function');\n    }\n    var dependencies = options.dependencies;\n    var init = options.init;\n    var getTransferables = options.getTransferables;\n    var workerId = options.workerId;\n    if (workerId == null) {\n      workerId = '#default';\n    }\n    var id = \"workerModule\" + ++_workerModuleId;\n    var name = options.name || id;\n    var registrationThenable = null;\n    dependencies = dependencies && dependencies.map(function (dep) {\n      // Wrap raw functions as worker modules with no dependencies\n      if (typeof dep === 'function' && !dep.workerModuleData) {\n        _allowInitAsString = true;\n        dep = defineWorkerModule({\n          workerId: workerId,\n          name: \"<\" + name + \"> function dependency: \" + dep.name,\n          init: \"function(){return (\\n\" + stringifyFunction(dep) + \"\\n)}\"\n        });\n        _allowInitAsString = false;\n      }\n      // Grab postable data for worker modules\n      if (dep && dep.workerModuleData) {\n        dep = dep.workerModuleData;\n      }\n      return dep;\n    });\n    function moduleFunc() {\n      var args = [],\n        len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      // Register this module if needed\n      if (!registrationThenable) {\n        registrationThenable = callWorker(workerId, 'registerModule', moduleFunc.workerModuleData);\n      }\n\n      // Invoke the module, returning a thenable\n      return registrationThenable.then(function (ref) {\n        var isCallable = ref.isCallable;\n        if (isCallable) {\n          return callWorker(workerId, 'callModule', {\n            id: id,\n            args: args\n          });\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function');\n        }\n      });\n    }\n    moduleFunc.workerModuleData = {\n      isWorkerModule: true,\n      id: id,\n      name: name,\n      dependencies: dependencies,\n      init: stringifyFunction(init),\n      getTransferables: getTransferables && stringifyFunction(getTransferables)\n    };\n    return moduleFunc;\n  }\n\n  /**\n   * Stringifies a function into a form that can be deserialized in the worker\n   * @param fn\n   */\n  function stringifyFunction(fn) {\n    var str = fn.toString();\n    // If it was defined in object method/property format, it needs to be modified\n    if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n      str = 'function ' + str;\n    }\n    return str;\n  }\n  function getWorker(workerId) {\n    var worker = workers[workerId];\n    if (!worker) {\n      // Bootstrap the worker's content\n      var bootstrap = stringifyFunction(workerBootstrap);\n\n      // Create the worker from the bootstrap function content\n      worker = workers[workerId] = new Worker(URL.createObjectURL(new Blob([\"/** Worker Module Bootstrap: \" + workerId.replace(/\\*/g, '') + \" **/\\n\\n;(\" + bootstrap + \")()\"], {\n        type: 'application/javascript'\n      })));\n\n      // Single handler for response messages from the worker\n      worker.onmessage = function (e) {\n        var response = e.data;\n        var msgId = response.messageId;\n        var callback = openRequests[msgId];\n        if (!callback) {\n          throw new Error('WorkerModule response with empty or unknown messageId');\n        }\n        delete openRequests[msgId];\n        openRequests.count--;\n        callback(response);\n      };\n    }\n    return worker;\n  }\n\n  // Issue a call to the worker with a callback to handle the response\n  function callWorker(workerId, action, data) {\n    var thenable = Thenable();\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        thenable.resolve(response.result);\n      } else {\n        thenable.reject(new Error(\"Error in worker \" + action + \" call: \" + response.error));\n      }\n    };\n    openRequests._count++;\n    if (openRequests.count > 1000) {\n      //detect leaks\n      console.warn('Large number of open WorkerModule requests, some may not be returning');\n    }\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n    return thenable;\n  }\n\n  /**\n   * Just the {@link Thenable} function wrapped as a worker module. If another worker\n   * module needs Thenable as a dependency, it's better to pass this module rather than\n   * the raw function in its `dependencies` array so it only gets registered once.\n   */\n  var ThenableWorkerModule = defineWorkerModule({\n    name: 'Thenable',\n    dependencies: [Thenable],\n    init: function init(Thenable) {\n      return Thenable;\n    }\n  });\n  exports.Thenable = Thenable;\n  exports.ThenableWorkerModule = ThenableWorkerModule;\n  exports.defineWorkerModule = defineWorkerModule;\n  exports.stringifyFunction = stringifyFunction;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","troika_worker_utils","BespokeThenable","state","queue","value","scheduled","completeCalled","then","onResolve","onReject","nextThenable","handleNext","cb","isFn","result","recursiveError","resultThen","getThenableThen","call","resolve","reject","err","push","scheduleQueueFlush","oneTime","val","complete","reason","st","ignoreThrow","thenableObj","valThen","v","e","setTimeout","flushQueue","q","forEach","callIt","fn","called","args","len","arguments","length","apply","TypeError","NativePromiseThenable","promise","Promise","res","rej","bind","Thenable","workerBootstrap","modules","Object","create","registerModule","ref","callback","id","name","dependencies","init","getTransferables","map","dep","isWorkerModule","depResult","Error","rehydrate","console","error","noLog","callModule","ref$1","handleResult","tx","Array","isArray","undefined","str","troikaDefine","r","url","URL","createObjectURL","Blob","replace","type","importScripts","revokeObjectURL","addEventListener","data","messageId","action","postMessage","success","message","isCallable","transferables","stack","_workerModuleId","_messageId","_allowInitAsString","workers","openRequests","_count","defineWorkerModule","options","workerId","registrationThenable","workerModuleData","stringifyFunction","moduleFunc","callWorker","toString","test","getWorker","worker","bootstrap","Worker","onmessage","response","msgId","count","thenable","warn","ThenableWorkerModule","defineProperty"],"sources":["/Users/mac/Desktop/react-3js-word-sphere/node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.troika_worker_utils = {}));\n}(this, (function (exports) { 'use strict';\n\n  /**\n   * Lightweight thenable implementation that is entirely self-contained within a single\n   * function with no external dependencies so it can be easily shipped across to a WorkerModule.\n   *\n   * This implementation conforms fully to the Promises/A+ spec so it can safely interoperate\n   * with other thenable implementations. https://github.com/promises-aplus/promises-spec\n   *\n   * *However*, it is _not_ a full implementation of ES2015 Promises, e.g. it does not\n   * have the same constructor signature and does not expose a `catch` method or the static\n   * `resolve`/`reject`/`all`/`race` initializer methods. If you need to hand a Thenable\n   * instance off to consuming code that may expect a true Promise, you'll want to wrap it\n   * in a native-or-polyfilled Promise first.\n   *\n   * (Why yet another Promises/A+ implementation? Great question. We needed a polyfill-like\n   * thing that was (a) wrapped in a single function for easy serialization across to a Worker,\n   * and (b) was as small as possible -- at ~900B minified (~500B gzipped) this is the smallest\n   * implementation I've found. And also, exercises like this are challenging and fun.)\n   */\n  function BespokeThenable() {\n    var state = 0; // 0=pending, 1=fulfilled, -1=rejected\n    var queue = [];\n    var value;\n    var scheduled = 0;\n    var completeCalled = 0;\n\n    function then(onResolve, onReject) {\n      var nextThenable = BespokeThenable();\n\n      function handleNext() {\n        var cb = state > 0 ? onResolve : onReject;\n        if (isFn(cb)) {\n          try {\n            var result = cb(value);\n            if (result === nextThenable) {\n              recursiveError();\n            }\n            var resultThen = getThenableThen(result);\n            if (resultThen) {\n              resultThen.call(result, nextThenable.resolve, nextThenable.reject);\n            } else {\n              nextThenable.resolve(result);\n            }\n          } catch (err) {\n            nextThenable.reject(err);\n          }\n        } else {\n          nextThenable[state > 0 ? 'resolve' : 'reject'](value);\n        }\n      }\n\n      queue.push(handleNext);\n      if (state) {\n        scheduleQueueFlush();\n      }\n      return nextThenable\n    }\n\n    var resolve = oneTime(function (val) {\n      if (!completeCalled) {\n        complete(1, val);\n      }\n    });\n\n    var reject = oneTime(function (reason) {\n      if (!completeCalled) {\n        complete(-1, reason);\n      }\n    });\n\n    function complete(st, val) {\n      completeCalled++;\n      var ignoreThrow = 0;\n      try {\n        if (val === thenableObj) {\n          recursiveError();\n        }\n        var valThen = st > 0 && getThenableThen(val);\n        if (valThen) {\n          valThen.call(val, oneTime(function (v) {\n            ignoreThrow++;\n            complete(1, v);\n          }), oneTime(function (v) {\n            ignoreThrow++;\n            complete(-1, v);\n          }));\n        } else {\n          state = st;\n          value = val;\n          scheduleQueueFlush();\n        }\n      } catch(e) {\n        if (!state && !ignoreThrow) {\n          complete(-1, e);\n        }\n      }\n    }\n\n    function scheduleQueueFlush() {\n      if (!scheduled) {\n        setTimeout(flushQueue, 0); //TODO setImmediate or postMessage approach if available?\n        scheduled = 1;\n      }\n    }\n\n    function flushQueue() {\n      var q = queue;\n      scheduled = 0;\n      queue = [];\n      q.forEach(callIt);\n    }\n\n    function callIt(fn) {\n      fn();\n    }\n\n    function getThenableThen(val) {\n      var valThen = val && (isFn(val) || typeof val === 'object') && val.then;\n      return isFn(valThen) && valThen\n    }\n\n    function oneTime(fn) {\n      var called = 0;\n      return function() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        if (!called++) {\n          fn.apply(this, args);\n        }\n      }\n    }\n\n    function recursiveError() {\n      throw new TypeError('Chaining cycle detected')\n    }\n\n    var isFn = function (v) { return typeof v === 'function'; };\n\n    var thenableObj = {\n      then: then,\n      resolve: resolve,\n      reject: reject\n    };\n    return thenableObj\n  }\n\n\n  /**\n   * Thenable implementation that uses a native Promise under the covers. This implementation\n   * is preferred if Promise is available, for better performance and dev tools integration.\n   * @constructor\n   */\n  function NativePromiseThenable() {\n    var resolve, reject;\n    var promise = new Promise(function (res, rej) {\n      resolve = res;\n      reject = rej;\n    });\n    return {\n      then: promise.then.bind(promise),\n      resolve: resolve,\n      reject: reject\n    }\n  }\n\n\n  /**\n   * Choose the best Thenable implementation and export it as the default.\n   */\n  var Thenable = (\n    typeof Promise === 'function' ? NativePromiseThenable : BespokeThenable\n  );\n\n  /**\n   * Main content for the worker that handles the loading and execution of\n   * modules within it.\n   */\n  function workerBootstrap() {\n    var modules = Object.create(null);\n\n    // Handle messages for registering a module\n    function registerModule(ref, callback) {\n      var id = ref.id;\n      var name = ref.name;\n      var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n      var init = ref.init; if ( init === void 0 ) init = function(){};\n      var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n      // Only register once\n      if (modules[id]) { return }\n\n      try {\n        // If any dependencies are modules, ensure they're registered and grab their value\n        dependencies = dependencies.map(function (dep) {\n          if (dep && dep.isWorkerModule) {\n            registerModule(dep, function (depResult) {\n              if (depResult instanceof Error) { throw depResult }\n            });\n            dep = modules[dep.id].value;\n          }\n          return dep\n        });\n\n        // Rehydrate functions\n        init = rehydrate((\"<\" + name + \">.init\"), init);\n        if (getTransferables) {\n          getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n        }\n\n        // Initialize the module and store its value\n        var value = null;\n        if (typeof init === 'function') {\n          value = init.apply(void 0, dependencies);\n        } else {\n          console.error('worker module init function failed to rehydrate');\n        }\n        modules[id] = {\n          id: id,\n          value: value,\n          getTransferables: getTransferables\n        };\n        callback(value);\n      } catch(err) {\n        if (!(err && err.noLog)) {\n          console.error(err);\n        }\n        callback(err);\n      }\n    }\n\n    // Handle messages for calling a registered module's result function\n    function callModule(ref, callback) {\n      var ref$1;\n\n      var id = ref.id;\n      var args = ref.args;\n      if (!modules[id] || typeof modules[id].value !== 'function') {\n        callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n      }\n      try {\n        var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n        if (result && typeof result.then === 'function') {\n          result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n        } else {\n          handleResult(result);\n        }\n      } catch(err) {\n        callback(err);\n      }\n      function handleResult(result) {\n        try {\n          var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n          if (!tx || !Array.isArray(tx) || !tx.length) {\n            tx = undefined; //postMessage is very picky about not passing null or empty transferables\n          }\n          callback(result, tx);\n        } catch(err) {\n          console.error(err);\n          callback(err);\n        }\n      }\n    }\n\n    function rehydrate(name, str) {\n      var result = void 0;\n      self.troikaDefine = function (r) { return result = r; };\n      var url = URL.createObjectURL(\n        new Blob(\n          [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n          {type: 'application/javascript'}\n        )\n      );\n      try {\n        importScripts(url);\n      } catch(err) {\n        console.error(err);\n      }\n      URL.revokeObjectURL(url);\n      delete self.troikaDefine;\n      return result\n    }\n\n    // Handler for all messages within the worker\n    self.addEventListener('message', function (e) {\n      var ref = e.data;\n      var messageId = ref.messageId;\n      var action = ref.action;\n      var data = ref.data;\n      try {\n        // Module registration\n        if (action === 'registerModule') {\n          registerModule(data, function (result) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: {isCallable: typeof result === 'function'}\n              });\n            }\n          });\n        }\n        // Invocation\n        if (action === 'callModule') {\n          callModule(data, function (result, transferables) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: result\n              }, transferables || undefined);\n            }\n          });\n        }\n      } catch(err) {\n        postMessage({\n          messageId: messageId,\n          success: false,\n          error: err.stack\n        });\n      }\n    });\n  }\n\n  var _workerModuleId = 0;\n  var _messageId = 0;\n  var _allowInitAsString = false;\n  var workers = Object.create(null);\n  var openRequests = Object.create(null);\n  openRequests._count = 0;\n\n\n  /**\n   * Define a module of code that will be executed with a web worker. This provides a simple\n   * interface for moving chunks of logic off the main thread, and managing their dependencies\n   * among one another.\n   *\n   * @param {object} options\n   * @param {function} options.init - The main function that initializes the module. This will be run\n   *        within the worker, and will be passed the resolved dependencies as arguments. Its\n   *        return value becomes the module's content, which can then be used by other modules\n   *        that depend on it. This function can perform any logic using those dependencies, but\n   *        must not depend on anything from its parent closures.\n   * @param {array} [options.dependencies] - Provides any dependencies required by the init function:\n   *        - Primitives like strings, numbers, booleans\n   *        - Raw functions; these will be stringified and rehydrated within the worker so they\n   *          must not depend on anything from their parent closures\n   *        - Other worker modules; these will be resolved within the worker, and therefore modules\n   *          that provide functions can be called without having to cross the worker/main thread\n   *          boundary.\n   * @param {function} [options.getTransferables] - An optional function that will be run in the worker\n   *        just before posting the response value from a module call back to the main thread.\n   *        It will be passed that response value, and if it returns an array then that will be\n   *        used as the \"transferables\" parameter to `postMessage`. Use this if there are values\n   *        in the response that can/should be transfered rather than cloned.\n   * @param {string} [options.name] - A descriptive name for this module; this can be useful for\n   *        debugging but is not currently used for anything else.\n   * @param {string} [options.workerId] - By default all modules will run in the same dedicated worker,\n   *        but if you want to use multiple workers you can pass a `workerId` to indicate a specific\n   *        worker to spawn. Note that each worker is completely standalone and no data or state will\n   *        be shared between them. If a worker module is used as a dependency by worker modules\n   *        using different `workerId`s, then that dependency will be re-registered in each worker.\n   * @return {function(...[*]): {then}}\n   */\n  function defineWorkerModule(options) {\n    if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n      throw new Error('requires `options.init` function')\n    }\n    var dependencies = options.dependencies;\n    var init = options.init;\n    var getTransferables = options.getTransferables;\n    var workerId = options.workerId;\n    if (workerId == null) {\n      workerId = '#default';\n    }\n    var id = \"workerModule\" + (++_workerModuleId);\n    var name = options.name || id;\n    var registrationThenable = null;\n\n    dependencies = dependencies && dependencies.map(function (dep) {\n      // Wrap raw functions as worker modules with no dependencies\n      if (typeof dep === 'function' && !dep.workerModuleData) {\n        _allowInitAsString = true;\n        dep = defineWorkerModule({\n          workerId: workerId,\n          name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n          init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n        });\n        _allowInitAsString = false;\n      }\n      // Grab postable data for worker modules\n      if (dep && dep.workerModuleData) {\n        dep = dep.workerModuleData;\n      }\n      return dep\n    });\n\n    function moduleFunc() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Register this module if needed\n      if (!registrationThenable) {\n        registrationThenable = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      }\n\n      // Invoke the module, returning a thenable\n      return registrationThenable.then(function (ref) {\n        var isCallable = ref.isCallable;\n\n        if (isCallable) {\n          return callWorker(workerId,'callModule', {id: id, args: args})\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function')\n        }\n      })\n    }\n    moduleFunc.workerModuleData = {\n      isWorkerModule: true,\n      id: id,\n      name: name,\n      dependencies: dependencies,\n      init: stringifyFunction(init),\n      getTransferables: getTransferables && stringifyFunction(getTransferables)\n    };\n    return moduleFunc\n  }\n\n  /**\n   * Stringifies a function into a form that can be deserialized in the worker\n   * @param fn\n   */\n  function stringifyFunction(fn) {\n    var str = fn.toString();\n    // If it was defined in object method/property format, it needs to be modified\n    if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n      str = 'function ' + str;\n    }\n    return str\n  }\n\n\n  function getWorker(workerId) {\n    var worker = workers[workerId];\n    if (!worker) {\n      // Bootstrap the worker's content\n      var bootstrap = stringifyFunction(workerBootstrap);\n\n      // Create the worker from the bootstrap function content\n      worker = workers[workerId] = new Worker(\n        URL.createObjectURL(\n          new Blob(\n            [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n            {type: 'application/javascript'}\n          )\n        )\n      );\n\n      // Single handler for response messages from the worker\n      worker.onmessage = function (e) {\n        var response = e.data;\n        var msgId = response.messageId;\n        var callback = openRequests[msgId];\n        if (!callback) {\n          throw new Error('WorkerModule response with empty or unknown messageId')\n        }\n        delete openRequests[msgId];\n        openRequests.count--;\n        callback(response);\n      };\n    }\n    return worker\n  }\n\n  // Issue a call to the worker with a callback to handle the response\n  function callWorker(workerId, action, data) {\n    var thenable = Thenable();\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        thenable.resolve(response.result);\n      } else {\n        thenable.reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    openRequests._count++;\n    if (openRequests.count > 1000) { //detect leaks\n      console.warn('Large number of open WorkerModule requests, some may not be returning');\n    }\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n    return thenable\n  }\n\n  /**\n   * Just the {@link Thenable} function wrapped as a worker module. If another worker\n   * module needs Thenable as a dependency, it's better to pass this module rather than\n   * the raw function in its `dependencies` array so it only gets registered once.\n   */\n  var ThenableWorkerModule = defineWorkerModule({\n    name: 'Thenable',\n    dependencies: [Thenable],\n    init: function(Thenable) {\n      return Thenable\n    }\n  });\n\n  exports.Thenable = Thenable;\n  exports.ThenableWorkerModule = ThenableWorkerModule;\n  exports.defineWorkerModule = defineWorkerModule;\n  exports.stringifyFunction = stringifyFunction;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}